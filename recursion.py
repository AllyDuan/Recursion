"""
Student information for this assignment:

Replace <FULL NAME> with your name.
On my/our honor, Ally Duan and <FULL NAME>, this
programming assignment is my own work and I have not provided this code to
any other student.

I have read and understand the course syllabus's guidelines regarding Academic
Integrity. I understand that if I violate the Academic Integrity policy (e.g.
copy code from someone else, have the code generated by an LLM, or give my
code to someone else), the case shall be submitted to the Office of the Dean of
Students. Academic penalties up to and including an F in the course are likely.

UT EID 1: amd6894
UT EID 2:
"""
'''
def group_sum(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case
    if start >= len(nums):
        # return true or false based on if we have some sum equal to target
        return target == 0
    # decision that we try and undo
    if group_sum(start + 1, nums, target - nums[start]):
        return True
    return group_sum(start + 1, nums, target)


def group_sum_6(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target. Additionally, if there is are 6's present in the array, they must all
    be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # base case
    if start >= len(nums):
        # return true or false based on if we have some sum equal to target
        return target == 0

    if nums[start] == 6:
        return group_sum_6(start + 1, nums, target - nums[start])
    else:
        if group_sum_6(start + 1, nums, target - nums[start]):
            return True
    return group_sum_6(start + 1, nums, target)


def group_no_adj(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a value is chosen, the value immediately after
    (the value adjacent) cannot be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        # return true or false based on if we have some sum equal to target
        return target == 0
    # decision that we try and undo
    if group_no_adj(start + 2, nums, target - nums[start]):
        return True
    return group_no_adj(start + 1, nums, target)


def group_sum_5(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a multiple of 5 is in the array, it must be included
    If the value immediately following a multiple of 5 is 1, it must not be chosen

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        # return true or false based on if we have some sum equal to target
        return target == 0

    if (nums[start] % 5) == 0:
        if nums[start + 1] != 1:
            return group_sum_5(start + 1, nums, target - nums[start])
        else:
            return group_sum_5(start + 1, nums, target - nums[start])

    if group_sum_5(start + 1, nums, target - nums[start]):
        return True
    return group_sum_5(start + 1, nums, target)



def group_sum_clump(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if there is a group of identical numbers in succession,
    they must all be chosen, or none of them must be chosen.
    EX: [1, 2, 2, 2, 5, 2], all three of the middle 2's must be chosen, or none of them must be
    chosen to be included in the sum. One loop is allowed to check for identical numbers.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    # if the current target equals zero, we can sum to it
    if target == 0:
        return True
    
    # if the index is out of bounds the sum cannot be produced
    if start >= len(nums):
        return False

    prev = nums[start]
    curr_sum = nums[start]
    curr = start

    # sum all consecutive numbers with the same value
    while start + 1 < len(nums) and nums[start + 1] == prev:
        curr += 1
        curr_sum += nums[curr]

    # if we obtain the target from the current sum we can return true
    if target == curr_sum:
        return True
    
    # recursively test including the current sum and not including the current sum
    valid = group_sum_clump(curr + 1, nums, target - curr_sum) or group_sum_clump(curr + 1, nums, target)
    return valid
    



# TODO: Modify this function
def split_array(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    # recursive function that passes thorugh an empty array and use that to see if it goes on one side or another


    def split_helper(start, sum):
        # base case
        
        if len(nums) == 0:
            return False
        



    if len(nums) == 2:
        if nums[0] == nums[1]:
            return True
        return False

    left = []
    right = []

    if split_array(nums):
        return True
    return split_array(start + 1, nums, target)


# TODO: Modify this function. You may delete this comment when you are done.
def split_odd_10(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of one group must be odd, while the other group must be a multiple of 10
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """

# TODO: Modify this function. You may delete this comment when you are done.
def split_53(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Additionally, all multiples of 5 must be in one group, and all multiples of 3 (and not 5)
    must be in the other group
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """

'''


def group_sum(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        return target == 0

    if group_sum(start + 1, nums, target - nums[start]):
        return True

    return group_sum(start + 1, nums, target)


def group_sum_6(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to the
    given target. Additionally, if there is are 6's present in the array, they must all
    be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        return target == 0

    if nums[start] == 6:
        return group_sum_6(start + 1, nums, target - nums[start])
    else:
        if group_sum_6(start + 1, nums, target - nums[start]):
            return True
        return group_sum_6(start + 1, nums, target)



def group_no_adj(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a value is chosen, the value immediately after
    (the value adjacent) cannot be chosen.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        return target == 0

    if group_no_adj(start + 2, nums, target - nums[start]):
        return True

    return group_no_adj(start + 1, nums, target)


def group_sum_5(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if a multiple of 5 is in the array, it must be included
    If the value immediately following a multiple of 5 if 1, it must not be chosen

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        return target == 0

    if (nums[start] % 5) == 0:
        if nums[start + 1] != 1:
            return group_sum_5(start + 1, nums, target - nums[start])
        return group_sum_5(start + 1, nums, target - nums[start])

    if group_sum_5(start + 1, nums, target - nums[start]):
        return True

    return group_sum_5(start + 1, nums, target)


def group_sum_clump(start, nums, target):
    """
    Given a list of ints, determine if there exists a group of some ints that sum to
    the given target. Additionally, if there is a group of identical numbers in succession,
    they must all be chosen, or none of them must be chosen.
    EX: [1, 2, 2, 2, 5, 2], all three of the middle 2's must be chosen, or none of them must be
    chosen to be included in the sum. One loop is allowed to check for identical numbers.

    pre: start >= 0, len(nums) >= 0, target >= 0, nums will only contain ints
    post: return True if nums has a group of ints that sum to target, False otherwise
    """
    if start >= len(nums):
        return target == 0
    count = 1
    for i in range(start + 1, len(nums)):
        if nums[i] == nums[start]:
            count += 1
    return group_sum_clump(start + count, nums, target - (nums[start] * count)) or group_sum_clump(start + count, nums, target)


def split_array(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    def helper(nums, groups, index):
        sum1 = 0
        sum2 = 0
        for i in groups[0]:
            sum1 += i
        for n in groups[1]:
            sum2 += n

        if index == len(nums):
            if sum1 == sum2:
                return True
            return False

        groups[0].append(nums[index])
        if helper(nums, groups, index + 1):
            return True
        groups[0].pop()

        groups[1].append(nums[index])
        if helper(nums, groups, index + 1):
            return True
        groups[1].pop()

        return False

    if len(nums) == 0:
        return True
    return helper(nums, [[],[]], 0)


def split_odd_10(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of one group must be odd, while the other group must be a multiple of 10
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    def helper(nums, groups, index):
        sum1 = 0
        sum2 = 0
        for i in groups[0]:
            sum1 += i
        for n in groups[1]:
            sum2 += n

        if index == len(nums):
            if sum1 % 2 != 0 and sum2 % 10 == 0:
                return True
            elif sum2 % 2 != 0 and sum1 % 10 == 0:
                return True
            return False

        groups[0].append(nums[index])
        if helper(nums, groups, index + 1):
            return True
        groups[0].pop()

        groups[1].append(nums[index])
        if helper(nums, groups, index + 1):
            return True
        groups[1].pop()

        return False

    if len(nums) == 0:
        return False
    return helper(nums, [[],[]], 0)


def split_53(nums):
    """
    Given a list of ints, determine if the numbers can be split evenly into two groups
    The sum of these two groups must be equal
    Additionally, all multiples of 5 must be in one group, and all multiples of 3 (and not 5)
    must be in the other group
    Write a recursive helper to call from this function

    pre: len(nums) >= 0, nums will only contain ints
    post: return True if nums can be split, False otherwise
    """
    def helper(nums, groups, index):
        sum1 = 0
        sum2 = 0
        for i in groups[0]:
            sum1 += i
        for n in groups[1]:
            sum2 += n

        if index == len(nums):
            if sum1 != sum2:
                return False

            for num in groups[0]:
                if num % 5 == 0:
                    for value in groups[1]:
                        if value % 5 == 0:
                            return False
                elif num % 3 == 0:
                    for a in groups[0]:
                        if a % 3 == 0 and a % 5 != 0:
                            return False

            for r in groups[1]:
                if r % 5 == 0:
                    for b in groups[1]:
                        if b % 5 == 0:
                            return False
                elif r % 3 == 0:
                    for v in groups[0]:
                        if v % 3 == 0 and v % 5 != 0:
                            return False
            return True

        groups[0].append(nums[index])
        if helper(nums, groups, index + 1):
            return True
        groups[0].pop()

        groups[1].append(nums[index])
        if helper(nums, groups, index + 1):
            return True
        groups[1].pop()

        return False

    if len(nums) == 0:
        return False
    return helper(nums, [[],[]], 0)